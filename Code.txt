using NAudio.CoreAudioApi;
using System.Threading;
using NAudio.Wave;
using System;


class Program
{
    static void Main(string[] args)
    {
        Console.WriteLine("Starting audio capture from loopback (what you hear)...");
        
        // Set up loopback capture
        var capture = new WasapiLoopbackCapture(); // Captures output audio

        capture.DataAvailable += (s, e) =>
        {
            for (int i = 0; i < 1; i++) {
                Console.WriteLine($"{e.Buffer[50]}");
            }
            
            // You could stream, save, or process this buffer here: e.Buffer
        };

        capture.RecordingStopped += (s, e) =>
        {
            Console.WriteLine("Recording stopped.");
            capture.Dispose();
        };

        capture.StartRecording();
        Console.WriteLine("Press Enter to stop...");
        Console.ReadLine();
        capture.StopRecording();
    }
}











using SharpHook;


class Program
{

    private static int lastX = 0;
    private static int lastY = 0;


    static void Main()
    {
        // Create a new HookManager to manage input hooks
        var hook = new TaskPoolGlobalHook();


        hook.MouseMoved += OnMouseMoved;


        hook.Run(); // use async later alright bud
    }

    public static void OnMouseMoved(object s, MouseHookEventArgs e) {

        int currentX = e.Data.X;
        int currentY = e.Data.Y;

        int offsetX = currentX - lastX;
        int offsetY = currentY - lastY;

        lastX = currentX;
        lastY = currentY;

        Console.WriteLine($"Offset: ({offsetX}, {offsetY})");
    }
}












//<summery> 
//
// this is just a simple abbsorber Window
//
//var Test = new Window{
//    WindowState = WindowState.FullScreen,
//    Background = new SolidColorBrush(Avalonia.Media.Color.FromUInt32(0x00ffffff)),
//    ShowInTaskbar = false,
//    Title = "Abbsorber",
//};
//Test.Show();















            //Console.WriteLine($"{DeltaX} , {DeltaY}");

            // =============================
            // Virtual screens
            // =============================
            if (!OnVirtualDisplay) { 
            
            
                foreach (var connection in Connections.Devices.ConnectionList)
                {
                    if (connection != null &&
                        connection.Bounds != null &&
                        connection.MouseState == Connections.Constants.Transmit)
                    {
                        var bounds = connection.Bounds;

                        if (bounds == CurrentScreenBounds) continue;



                        // Entering left
                        if ((HasCrossedValue(PosX, DeltaX, (bounds.X - CriticalRegionSize), true)) &&
                            (bounds.Y <= PosY && PosY <= bounds.Y + bounds.Height))
                        {
                            //Console.WriteLine("TouchedBorder3");
                            //Console.WriteLine($" => {PosX} , {PosY}");
                            OffsetPositionX = bounds.X;
                            CurrentScreenBounds = bounds;
                            OnVirtualDisplay = true;
                            BorderHit = true;

                            if (OnVirtualMointorEnter != null) OnVirtualMointorEnter.Invoke();
                            MoveMouse(CriticalRegionSize + CursorThrow, y);
                            return;
                        }

                        // Entering right
                        if ((HasCrossedValue(PosX, DeltaX, (bounds.X + bounds.Width + CriticalRegionSize), false)) &&
                            (bounds.Y <= PosY && PosY <= bounds.Y + bounds.Height))
                        {
                            //Console.WriteLine("TouchedBorder4");
                            //Console.WriteLine($" => {PosX} , {PosY}");
                            OffsetPositionX = bounds.X + bounds.Width;
                            CurrentScreenBounds = bounds;
                            OnVirtualDisplay = true;
                            BorderHit = true;
                            if (OnVirtualMointorEnter != null) OnVirtualMointorEnter.Invoke();
                            MoveMouse(bounds.Width - CriticalRegionSize - CursorThrow, y);
                            return;
                        }
                    }
                }
            }

            // =============================
            // Physical screens
            // =============================
            if (SharedData.Device.Screens != null && OnVirtualDisplay)
            {
                foreach (var screen in SharedData.Device.Screens)
                {
                    var bounds = new Bounds(screen.Bounds.X, screen.Bounds.Y, screen.Bounds.Width, screen.Bounds.Height);

                    if (CurrentScreenBounds != null &&
                        CurrentScreenBounds.X == bounds.X &&
                        CurrentScreenBounds.Y == bounds.Y &&
                        CurrentScreenBounds.Width == bounds.Width &&
                        CurrentScreenBounds.Height == bounds.Height) 
                    {
                        continue;
                    }


                    // Left edge
                    if ((HasCrossedValue(PosX, DeltaX, (bounds.X - CriticalRegionSize), true)) &&
                        (bounds.Y <= PosY && PosY <= bounds.Y + bounds.Height))
                    {
                        CurrentScreenBounds = bounds;
                        OffsetPositionX = 0;
                        OnVirtualDisplay = false;
                        BorderHit = true;
                        if (OnVirtualMointorExit != null) OnVirtualMointorExit.Invoke();
                        MoveMouse(CriticalRegionSize + CursorThrow, y);
                        return;
                    }

                    // Right edge
                    if ((HasCrossedValue(PosX, DeltaX, (bounds.X + bounds.Width + CriticalRegionSize), false)) &&
                        (bounds.Y <= PosY && PosY <= bounds.Y + bounds.Height))
                    {
                        //Console.WriteLine(bounds.X + bounds.Width + CriticalRegionSize);
                        CurrentScreenBounds = bounds;
                        OffsetPositionX = 0;
                        OnVirtualDisplay = false;
                        BorderHit = true;
                        if (OnVirtualMointorExit != null) OnVirtualMointorExit.Invoke();
                        MoveMouse(bounds.X + bounds.Width - CriticalRegionSize - CursorThrow, y);
                        return;
                    }
                }
            }











        public static void TransmitMousePressButtons(int Button) {
            // x and y are there to check if you are on the right coordinates

            var xPos = CurrentPositionX + OffsetPositionX;
            var yPos = CurrentPositionY + OffsetPositionY;

            if (OnVirtualDisplay == false) return;

            foreach (var connection in Connections.Devices.ConnectionList)
            {
                if (connection.MouseState == Connections.Constants.Transmit)
                {

                    if (connection.Bounds == null) continue;

                    if (connection.Bounds.X <= xPos && (connection.Bounds.X + connection.Bounds.Width) >= xPos &&
                        connection.Bounds.Y <= yPos && (connection.Bounds.Y + connection.Bounds.Height) >= yPos)
                    {
                        var _command = new Commands.Mouse
                        {
                            MouseButtonPress = Button,
                        };

                        var _commandMessage = new MessageCommand
                        {
                            Type = Commands.Constants.CommandTypes.Mouse,
                            SequenceNumber = connection.SequenceNumber + 1,
                            Command = JsonSerializer.Serialize(_command)
                        };
                        connection.SequenceNumber += 1;

                        var messageudp = new MessageUDP
                        {
                            MessageType = Network.Constants.MessageTypes.Command,
                            Text = Encryptor.Encrypt(JsonSerializer.Serialize(_commandMessage), connection.Token),
                            IsEncrypted = true
                        };

                        if (connection.MacAddress != null)
                        {
                            ConnectionUDP.Send(MessageManager.MacToIP[connection.MacAddress], messageudp);
                        }


                    }
                }
            }

        }


        public static void TransmitMouseReleaseButtons(int Button)
        {
            // x and y are there to check if you are on the right coordinates

            var xPos = CurrentPositionX + OffsetPositionX;
            var yPos = CurrentPositionY + OffsetPositionY;

            if (OnVirtualDisplay == false) return;

            foreach (var connection in Connections.Devices.ConnectionList)
            {
                if (connection.MouseState == Connections.Constants.Transmit)
                {

                    if (connection.Bounds == null) continue;

                    if (connection.Bounds.X <= xPos && (connection.Bounds.X + connection.Bounds.Width) >= xPos &&
                        connection.Bounds.Y <= yPos && (connection.Bounds.Y + connection.Bounds.Height) >= yPos)
                    {
                        var _command = new Commands.Mouse
                        {
                            MouseButtonRelease = Button,
                        };

                        var _commandMessage = new MessageCommand
                        {
                            Type = Commands.Constants.CommandTypes.Mouse,
                            SequenceNumber = connection.SequenceNumber + 1,
                            Command = JsonSerializer.Serialize(_command)
                        };
                        connection.SequenceNumber += 1;

                        var messageudp = new MessageUDP
                        {
                            MessageType = Network.Constants.MessageTypes.Command,
                            Text = Encryptor.Encrypt(JsonSerializer.Serialize(_commandMessage), connection.Token),
                            IsEncrypted = true
                        };

                        if (connection.MacAddress != null)
                        {
                            ConnectionUDP.Send(MessageManager.MacToIP[connection.MacAddress], messageudp);
                        }


                    }
                }
            }

        }



        public static void TransmitMouseScroll(double delta){


            // x and y are there to check if you are on the right coordinates


            var xPos = CurrentPositionX + OffsetPositionX;
            var yPos = CurrentPositionY + OffsetPositionY;

            if (OnVirtualDisplay == false) return;

            foreach (var connection in Connections.Devices.ConnectionList)
            {
                if (connection.MouseState == Connections.Constants.Transmit)
                {

                    if (connection.Bounds == null) continue;

                    if (connection.Bounds.X <= xPos && (connection.Bounds.X + connection.Bounds.Width) >= xPos &&
                        connection.Bounds.Y <= yPos && (connection.Bounds.Y + connection.Bounds.Height) >= yPos)
                    {
                        var _command = new Commands.Mouse
                        {
                            ScrollDelta = delta,
                        };

                        var _commandMessage = new MessageCommand
                        {
                            Type = Commands.Constants.CommandTypes.Mouse,
                            SequenceNumber = connection.SequenceNumber + 1,
                            Command = JsonSerializer.Serialize(_command)
                        };
                        connection.SequenceNumber += 1;

                        var messageudp = new MessageUDP
                        {
                            MessageType = Network.Constants.MessageTypes.Command,
                            Text = Encryptor.Encrypt(JsonSerializer.Serialize(_commandMessage), connection.Token),
                            IsEncrypted = true
                        };

                        if (connection.MacAddress != null)
                        {
                            ConnectionUDP.Send(MessageManager.MacToIP[connection.MacAddress], messageudp);
                        }


                    }
                }
            }
        }