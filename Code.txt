using NAudio.CoreAudioApi;
using System.Threading;
using NAudio.Wave;
using System;


class Program
{
    static void Main(string[] args)
    {
        Console.WriteLine("Starting audio capture from loopback (what you hear)...");
        
        // Set up loopback capture
        var capture = new WasapiLoopbackCapture(); // Captures output audio

        capture.DataAvailable += (s, e) =>
        {
            for (int i = 0; i < 1; i++) {
                Console.WriteLine($"{e.Buffer[50]}");
            }
            
            // You could stream, save, or process this buffer here: e.Buffer
        };

        capture.RecordingStopped += (s, e) =>
        {
            Console.WriteLine("Recording stopped.");
            capture.Dispose();
        };

        capture.StartRecording();
        Console.WriteLine("Press Enter to stop...");
        Console.ReadLine();
        capture.StopRecording();
    }
}











using SharpHook;


class Program
{

    private static int lastX = 0;
    private static int lastY = 0;


    static void Main()
    {
        // Create a new HookManager to manage input hooks
        var hook = new TaskPoolGlobalHook();


        hook.MouseMoved += OnMouseMoved;


        hook.Run(); // use async later alright bud
    }

    public static void OnMouseMoved(object s, MouseHookEventArgs e) {

        int currentX = e.Data.X;
        int currentY = e.Data.Y;

        int offsetX = currentX - lastX;
        int offsetY = currentY - lastY;

        lastX = currentX;
        lastY = currentY;

        Console.WriteLine($"Offset: ({offsetX}, {offsetY})");
    }
}












//<summery> 
//
// this is just a simple abbsorber Window
//
//var Test = new Window{
//    WindowState = WindowState.FullScreen,
//    Background = new SolidColorBrush(Avalonia.Media.Color.FromUInt32(0x00ffffff)),
//    ShowInTaskbar = false,
//    Title = "Abbsorber",
//};
//Test.Show();















            //Console.WriteLine($"{DeltaX} , {DeltaY}");

            // =============================
            // Virtual screens
            // =============================
            if (!OnVirtualDisplay) { 
            
            
                foreach (var connection in Connections.Devices.ConnectionList)
                {
                    if (connection != null &&
                        connection.Bounds != null &&
                        connection.MouseState == Connections.Constants.Transmit)
                    {
                        var bounds = connection.Bounds;

                        if (bounds == CurrentScreenBounds) continue;



                        // Entering left
                        if ((HasCrossedValue(PosX, DeltaX, (bounds.X - CriticalRegionSize), true)) &&
                            (bounds.Y <= PosY && PosY <= bounds.Y + bounds.Height))
                        {
                            //Console.WriteLine("TouchedBorder3");
                            //Console.WriteLine($" => {PosX} , {PosY}");
                            OffsetPositionX = bounds.X;
                            CurrentScreenBounds = bounds;
                            OnVirtualDisplay = true;
                            BorderHit = true;

                            if (OnVirtualMointorEnter != null) OnVirtualMointorEnter.Invoke();
                            MoveMouse(CriticalRegionSize + CursorThrow, y);
                            return;
                        }

                        // Entering right
                        if ((HasCrossedValue(PosX, DeltaX, (bounds.X + bounds.Width + CriticalRegionSize), false)) &&
                            (bounds.Y <= PosY && PosY <= bounds.Y + bounds.Height))
                        {
                            //Console.WriteLine("TouchedBorder4");
                            //Console.WriteLine($" => {PosX} , {PosY}");
                            OffsetPositionX = bounds.X + bounds.Width;
                            CurrentScreenBounds = bounds;
                            OnVirtualDisplay = true;
                            BorderHit = true;
                            if (OnVirtualMointorEnter != null) OnVirtualMointorEnter.Invoke();
                            MoveMouse(bounds.Width - CriticalRegionSize - CursorThrow, y);
                            return;
                        }
                    }
                }
            }

            // =============================
            // Physical screens
            // =============================
            if (SharedData.Device.Screens != null && OnVirtualDisplay)
            {
                foreach (var screen in SharedData.Device.Screens)
                {
                    var bounds = new Bounds(screen.Bounds.X, screen.Bounds.Y, screen.Bounds.Width, screen.Bounds.Height);

                    if (CurrentScreenBounds != null &&
                        CurrentScreenBounds.X == bounds.X &&
                        CurrentScreenBounds.Y == bounds.Y &&
                        CurrentScreenBounds.Width == bounds.Width &&
                        CurrentScreenBounds.Height == bounds.Height) 
                    {
                        continue;
                    }


                    // Left edge
                    if ((HasCrossedValue(PosX, DeltaX, (bounds.X - CriticalRegionSize), true)) &&
                        (bounds.Y <= PosY && PosY <= bounds.Y + bounds.Height))
                    {
                        CurrentScreenBounds = bounds;
                        OffsetPositionX = 0;
                        OnVirtualDisplay = false;
                        BorderHit = true;
                        if (OnVirtualMointorExit != null) OnVirtualMointorExit.Invoke();
                        MoveMouse(CriticalRegionSize + CursorThrow, y);
                        return;
                    }

                    // Right edge
                    if ((HasCrossedValue(PosX, DeltaX, (bounds.X + bounds.Width + CriticalRegionSize), false)) &&
                        (bounds.Y <= PosY && PosY <= bounds.Y + bounds.Height))
                    {
                        //Console.WriteLine(bounds.X + bounds.Width + CriticalRegionSize);
                        CurrentScreenBounds = bounds;
                        OffsetPositionX = 0;
                        OnVirtualDisplay = false;
                        BorderHit = true;
                        if (OnVirtualMointorExit != null) OnVirtualMointorExit.Invoke();
                        MoveMouse(bounds.X + bounds.Width - CriticalRegionSize - CursorThrow, y);
                        return;
                    }
                }
            }











        public static void TransmitMousePressButtons(int Button) {
            // x and y are there to check if you are on the right coordinates

            var xPos = CurrentPositionX + OffsetPositionX;
            var yPos = CurrentPositionY + OffsetPositionY;

            if (OnVirtualDisplay == false) return;

            foreach (var connection in Connections.Devices.ConnectionList)
            {
                if (connection.MouseState == Connections.Constants.Transmit)
                {

                    if (connection.Bounds == null) continue;

                    if (connection.Bounds.X <= xPos && (connection.Bounds.X + connection.Bounds.Width) >= xPos &&
                        connection.Bounds.Y <= yPos && (connection.Bounds.Y + connection.Bounds.Height) >= yPos)
                    {
                        var _command = new Commands.Mouse
                        {
                            MouseButtonPress = Button,
                        };

                        var _commandMessage = new MessageCommand
                        {
                            Type = Commands.Constants.CommandTypes.Mouse,
                            SequenceNumber = connection.SequenceNumber + 1,
                            Command = JsonSerializer.Serialize(_command)
                        };
                        connection.SequenceNumber += 1;

                        var messageudp = new MessageUDP
                        {
                            MessageType = Network.Constants.MessageTypes.Command,
                            Text = Encryptor.Encrypt(JsonSerializer.Serialize(_commandMessage), connection.Token),
                            IsEncrypted = true
                        };

                        if (connection.MacAddress != null)
                        {
                            ConnectionUDP.Send(MessageManager.MacToIP[connection.MacAddress], messageudp);
                        }


                    }
                }
            }

        }


        public static void TransmitMouseReleaseButtons(int Button)
        {
            // x and y are there to check if you are on the right coordinates

            var xPos = CurrentPositionX + OffsetPositionX;
            var yPos = CurrentPositionY + OffsetPositionY;

            if (OnVirtualDisplay == false) return;

            foreach (var connection in Connections.Devices.ConnectionList)
            {
                if (connection.MouseState == Connections.Constants.Transmit)
                {

                    if (connection.Bounds == null) continue;

                    if (connection.Bounds.X <= xPos && (connection.Bounds.X + connection.Bounds.Width) >= xPos &&
                        connection.Bounds.Y <= yPos && (connection.Bounds.Y + connection.Bounds.Height) >= yPos)
                    {
                        var _command = new Commands.Mouse
                        {
                            MouseButtonRelease = Button,
                        };

                        var _commandMessage = new MessageCommand
                        {
                            Type = Commands.Constants.CommandTypes.Mouse,
                            SequenceNumber = connection.SequenceNumber + 1,
                            Command = JsonSerializer.Serialize(_command)
                        };
                        connection.SequenceNumber += 1;

                        var messageudp = new MessageUDP
                        {
                            MessageType = Network.Constants.MessageTypes.Command,
                            Text = Encryptor.Encrypt(JsonSerializer.Serialize(_commandMessage), connection.Token),
                            IsEncrypted = true
                        };

                        if (connection.MacAddress != null)
                        {
                            ConnectionUDP.Send(MessageManager.MacToIP[connection.MacAddress], messageudp);
                        }


                    }
                }
            }

        }



        public static void TransmitMouseScroll(double delta){


            // x and y are there to check if you are on the right coordinates


            var xPos = CurrentPositionX + OffsetPositionX;
            var yPos = CurrentPositionY + OffsetPositionY;

            if (OnVirtualDisplay == false) return;

            foreach (var connection in Connections.Devices.ConnectionList)
            {
                if (connection.MouseState == Connections.Constants.Transmit)
                {

                    if (connection.Bounds == null) continue;

                    if (connection.Bounds.X <= xPos && (connection.Bounds.X + connection.Bounds.Width) >= xPos &&
                        connection.Bounds.Y <= yPos && (connection.Bounds.Y + connection.Bounds.Height) >= yPos)
                    {
                        var _command = new Commands.Mouse
                        {
                            ScrollDelta = delta,
                        };

                        var _commandMessage = new MessageCommand
                        {
                            Type = Commands.Constants.CommandTypes.Mouse,
                            SequenceNumber = connection.SequenceNumber + 1,
                            Command = JsonSerializer.Serialize(_command)
                        };
                        connection.SequenceNumber += 1;

                        var messageudp = new MessageUDP
                        {
                            MessageType = Network.Constants.MessageTypes.Command,
                            Text = Encryptor.Encrypt(JsonSerializer.Serialize(_commandMessage), connection.Token),
                            IsEncrypted = true
                        };

                        if (connection.MacAddress != null)
                        {
                            ConnectionUDP.Send(MessageManager.MacToIP[connection.MacAddress], messageudp);
                        }


                    }
                }
            }
        }













        public async void TestClipboard()
        {
            var topLevel = TopLevel.GetTopLevel(this);
            if (topLevel == null) return;

            // Check for text
            var text = await topLevel.Clipboard.GetTextAsync();
            if (!string.IsNullOrEmpty(text))
            {
                Console.WriteLine("Text copied: " + text);
            }

            // Check for files
            var filesObj = await topLevel.Clipboard.GetDataAsync("Files");

            if (filesObj != null){
                // Try casting to IEnumerable
                if (filesObj is IEnumerable<object> files){
                    foreach (var file in files){
                        // Try casting each file to IStorageItem
                        if (file is Avalonia.Platform.Storage.IStorageItem storageItem){
                            Console.WriteLine("Copied file: " + storageItem.Path); // or .Path if available
                        }
                    }
                }
                else{
                    Console.WriteLine("Clipboard files data is not enumerable!");
                }
            }
        }















    public static class Audio
    {


        public static WaveOutEvent? WaveOut;
        public static WaveFormat? WaveFormat;
        public static MixingSampleProvider? Mixer;
        public static WasapiLoopbackCapture? Capture;


        public static void Start()
        {

            var enumerator = new NAudio.CoreAudioApi.MMDeviceEnumerator();
            var defaultDevice = enumerator.GetDefaultAudioEndpoint(DataFlow.Render, Role.Console);

            WaveFormat = defaultDevice.AudioClient.MixFormat;

            Mixer = new MixingSampleProvider(WaveFormat.CreateIeeeFloatWaveFormat(
                WaveFormat.SampleRate,
                WaveFormat.Channels))
            {
                ReadFully = true
            };

            WaveOut = new WaveOutEvent();
            Capture = new WasapiLoopbackCapture()
            {
                ShareMode = AudioClientShareMode.Shared,
                WaveFormat = WaveFormat,
            };



            WaveFormat = Capture.WaveFormat;









            Capture.DataAvailable += OnDataAvailable;


            Capture.StartRecording();


            WaveOut.Init(Mixer);
            WaveOut.Play();

            MessageManager.OnCommandAudio += OnReceiveCommand;
        }


        private static void OnDataAvailable(object? sender, WaveInEventArgs e){
            int bytesPerSlice = Setting.Config.AudioBufferSize;

            for (int offset = 0; offset < e.BytesRecorded; offset += bytesPerSlice)
            {
                int sliceLength = Math.Min(bytesPerSlice, e.BytesRecorded - offset);
                byte[] slice = new byte[sliceLength];
                Array.Copy(e.Buffer, offset, slice, 0, sliceLength);

                OnDataSlice(slice, slice.Length);
            }
        }

        public static void OnDataSlice(byte[] slice, int length) {

            TransmitAudio(slice, length);

            
        }


        public static void Stop(){
            if (Capture == null) return;


            Capture.StopRecording();
            Capture.Dispose();

        }





        public static void TransmitAudio(byte[] buffer, int bytesRecorded)
        {
            // this function is going to transmit a text to the other devices to store it in
            // the clipboard

            // int offset -> still havent been implemented look through it

            foreach (var connection in Connections.Devices.ConnectionList){

                if (connection.AudioState != Connections.Constants.Transmit) continue;

                var _command = new Commands.Audio{
                    Buffer = buffer,
                    BytesRecorded = bytesRecorded,
                };

                var _commandMessage = new MessageCommand{
                    Type = Commands.Constants.CommandTypes.Audio,
                    SequenceNumber = connection.SequenceNumber + 1,
                    Command = JsonSerializer.Serialize(_command)
                };
                connection.SequenceNumber += 1;

                var messageudp = new MessageUDP{
                    MessageType = Network.Constants.MessageTypes.Command,
                    Text = Encryptor.Encrypt(JsonSerializer.Serialize(_commandMessage), connection.Token),
                    IsEncrypted = true
                };

                if (connection.MacAddress != null){
                    ConnectionUDP.Send(MessageManager.MacToIP[connection.MacAddress], messageudp);
                }
            }

        }


        public static void OnReceiveCommand(Commands.Audio command, Connection connection){


            if (Mixer == null) return;

            if (command.Buffer == null) return;
            if (command.BytesRecorded == null) return;


            if (connection.BufferedWaveProvider == null) {
                connection.BufferedWaveProvider = new BufferedWaveProvider(WaveFormat);
                Mixer.AddMixerInput(connection.BufferedWaveProvider.ToSampleProvider());
            }



            connection.BufferedWaveProvider.AddSamples(command.Buffer, 0, (int)command.BytesRecorded);


        }



    }